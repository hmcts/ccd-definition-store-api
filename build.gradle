buildscript {
    dependencies {
        classpath 'org.junit.platform:junit-platform-gradle-plugin:1.1.1'
    }
    dependencies {
        classpath "gradle.plugin.com.github.spotbugs:gradlePlugin:1.6.0"
    }
    dependencies {
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.6.2"
    }
    dependencies {
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.0'
    }
}

plugins {
    id 'application'
    id 'io.spring.dependency-management' version '1.0.5.RELEASE'
    id 'org.springframework.boot' version '1.5.12.RELEASE'
    id 'org.owasp.dependencycheck' version '3.1.2'
    id 'se.patrikerdes.use-latest-versions' version '0.2.1'
    id 'com.github.ben-manes.versions' version '0.17.0'
    id 'org.sonarqube' version '2.6.2'
    id 'jacoco'
    id 'checkstyle'
    id "com.github.kt3k.coveralls" version "2.8.2"
}

apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'application'
apply plugin: "org.sonarqube"
apply plugin: 'com.jfrog.bintray'
apply plugin: 'com.github.ben-manes.versions'
apply plugin: 'se.patrikerdes.use-latest-versions'
apply plugin: 'org.owasp.dependencycheck'

mainClassName = 'uk.gov.hmcts.ccd.definition.store.CaseDataAPIApplication'

// https://jeremylong.github.io/DependencyCheck/dependency-check-gradle/configuration.html
dependencyCheck {
    // Specifies if the build should be failed if a CVSS score above a specified level is identified.
    // range of 0-10 fails the build, anything greater and it doesn't fail the build
    failBuildOnCVSS = System.getProperty('dependencyCheck.failBuild') == 'false' ? 11 : 0
    suppressionFile = 'dependency-check-suppressions.xml'
    analyzers {
        // Disable scanning of .NET related binaries
        assemblyEnabled = false
    }
}

ext {
    junitJupiterVersion = '5.1.1'
    junitVintageVersion = '4.12.1'
    junitPlatformVersion = '1.0.1'
    orgMapstructVersion='1.2.0.Final'
    springBootVersion = '1.5.12.RELEASE'
    springfoxSwaggerVersion = '2.9.0'
    authCheckerVersion = '2.1.2'
    hamcrestVersion = '1.3'
    reformLogging= '2.2.1'
    limits = [ // test coverage success criteria
               'class' : 80
    ]
}

// tag::repositories[]
allprojects {

    group 'uk.gov.hmcts.ccd.definition'
    version '1.2.0-SNAPSHOT'

    repositories {
        mavenLocal()
        jcenter()
        maven {
            url  "https://dl.bintray.com/hmcts/hmcts-maven"
        }
    }

    apply plugin: 'java'

    ext {
        hibernateVersion = '5.2.16.Final'
        junitVersion = '4.12'
        junitJupiterVersion = '5.1.1'
        junitVintageVersion = '5.1.1'
        junitPlatformVersion = '1.1.1'
        orgMapstructVersion='1.2.0.Final'
        springBootVersion = '1.5.12.RELEASE'
        authCheckerVersion = '2.1.2'
        hamcrestVersion = '1.3'
        limits = [ // test coverage success criteria
                   'class' : 80
        ]
    }

    dependencies {
        compile group: 'uk.gov.hmcts.reform', name: 'java-logging', version: reformLogging
        compile group: 'uk.gov.hmcts.reform', name: 'java-logging-appinsights', version: reformLogging
        compile "org.hibernate:hibernate-core:${hibernateVersion}"
        compile "org.hibernate:hibernate-entitymanager:${hibernateVersion}"
        compile "uk.gov.hmcts.reform.auth:auth-checker-lib:${authCheckerVersion}"
        compile group: 'com.zaxxer', name: 'HikariCP', version: '2.7.9'
        testCompile "org.springframework.boot:spring-boot-starter-test:${springBootVersion}"
        testCompile 'io.github.openfeign:feign-jackson:9.7.0'
        testCompile "org.springframework.boot:spring-boot-starter-test:${springBootVersion}"
        testCompile "org.exparity:hamcrest-date:2.0.4"
        testCompile "org.springframework.boot:spring-boot-starter-test:${springBootVersion}"
        testCompile "io.rest-assured:rest-assured:3.1.0"
        testCompile "org.exparity:hamcrest-date:2.0.4"
        testCompile ("junit:junit") {
            exclude group: 'org.hamcrest'
        }
        testCompile "org.junit.jupiter:junit-jupiter-api:${junitJupiterVersion}"
        testRuntime "org.junit.jupiter:junit-jupiter-engine:${junitJupiterVersion}"
        testRuntime "org.junit.platform:junit-platform-launcher:${junitPlatformVersion}"
        testRuntime "org.junit.vintage:junit-vintage-engine:${junitVintageVersion}"
        testCompile "org.junit.jupiter:junit-jupiter-params:${junitJupiterVersion}"
    }

    checkstyle {
        maxWarnings = 999  // In the Ideal world this should be 0
        toolVersion = '8.8'
        configDir = new File(rootDir, 'config/checkstyle')
    }

    checkstyleMain.shouldRunAfter(compileJava)
    test.shouldRunAfter(checkstyleTest)
}

sourceCompatibility = 1.8
targetCompatibility = 1.8


// end::repositories[]

subprojects {
    version = project.version

    apply plugin: 'org.springframework.boot'
    apply plugin: 'org.junit.platform.gradle.plugin'
    apply plugin: 'jacoco'
    apply plugin: 'checkstyle'
    apply plugin: "com.github.spotbugs"
    apply plugin: "com.github.kt3k.coveralls"


    configurations {
        providedRuntime

        aatCompile.extendsFrom(testCompile)
        aatRuntime.extendsFrom(testRuntime)
    }

    junitPlatform {
        enableStandardTestTask true
    }

    dependencyUpdates.resolutionStrategy = {
        componentSelection { rules ->
            rules.all { ComponentSelection selection ->
                boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm'].any { qualifier ->
                    selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/
                }
                if (rejected) {
                    selection.reject('Release candidate')
                }
            }
        }
    }

    dependencies {
        compile group: 'uk.gov.hmcts.reform', name: 'java-logging', version: reformLogging
        compile group: 'uk.gov.hmcts.reform', name: 'java-logging-appinsights', version: reformLogging
        compile "org.hibernate:hibernate-core:${hibernateVersion}"
        compile "org.hibernate:hibernate-entitymanager:${hibernateVersion}"
        compile group: 'javax.inject', name: 'javax.inject', version: '1'

        // To avoid compiler warnings about @API annotations in JUnit5 code.
        testCompileOnly 'org.apiguardian:apiguardian-api:1.0.0'

        testCompile group: 'com.github.tomakehurst', name: 'wiremock', version: '2.17.0'
        testCompile group: 'com.opentable.components', name: 'otj-pg-embedded', version: '0.11.4'
        testCompile "org.hamcrest:hamcrest-core:${hamcrestVersion}"
        testCompile "org.hamcrest:hamcrest-library:${hamcrestVersion}"
        testCompile "org.junit.jupiter:junit-jupiter-api:${junitJupiterVersion}"
        testRuntime "org.junit.jupiter:junit-jupiter-engine:${junitJupiterVersion}"
        testRuntime "org.junit.platform:junit-platform-launcher:${junitPlatformVersion}"
        testRuntime "org.junit.vintage:junit-vintage-engine:${junitVintageVersion}"
        testCompile "org.junit.jupiter:junit-jupiter-params:${junitJupiterVersion}"
        testCompile "org.junit.platform:junit-platform-suite-api:${junitPlatformVersion}"
        testCompile "org.junit.platform:junit-platform-runner:${junitPlatformVersion}"
        testCompile "org.springframework:spring-test:4.3.16.RELEASE"
        testCompile "org.springframework:spring-webmvc:4.3.16.RELEASE"
        testCompile ("org.mockito:mockito-core:1.10.19") {
            exclude group: 'org.hamcrest'
        }
        testCompile "org.mockito:mockito-all:1.10.19"
        testCompile 'com.github.npathai:hamcrest-optional:2.0.0'
        testCompile group: 'org.springframework.cloud', name: 'spring-cloud-contract-wiremock', version: '1.2.4.RELEASE'
        testCompile group: 'org.hamcrest', name: 'hamcrest-junit', version: '2.0.0.0'
    }

    // from https://github.com/junit-team/junit5/issues/1024
    afterEvaluate {
        def junitPlatformTestTask = project.tasks.getByName('junitPlatformTest')

        // configure jacoco to analyze the junitPlatformTest task
        jacoco {
            // this tool version is compatible with
            toolVersion = "0.8.0"
            applyTo junitPlatformTestTask
        }

        // create junit platform jacoco task
        project.task(type: JacocoReport, "junitPlatformJacocoReport",
                {
                    executionData junitPlatformTestTask
                    sourceSets(sourceSets.main)
                    sourceDirectories = files(sourceSets.main.allSource.srcDirs)
                    classDirectories = files(sourceSets.main.output)

                    reports {
                        xml.enabled true
                        html.enabled true
                    }
                })

        jacocoTestReport {
            reports {
                // XML required by coveralls and for the below coverage checks
                // and html are generated by default
                xml.enabled true
                html.enabled true
            }

            doLast {
                def report = file("${jacoco.reportsDir}/test/jacocoTestReport.xml")
                logger.lifecycle("Checking coverage results: ${report}")

                def parser = new XmlParser()
                parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
                parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
                def results = parser.parse(report)

                def percentage = {
                    def covered = it.'@covered' as Double
                    def missed = it.'@missed' as Double
                    ((covered / (covered + missed)) * 100).round(2)
                }

                def counters = results.counter
                def metrics = [:]
                metrics << [
                        'class'      : percentage(counters.find { it.'@type'.equals('CLASS') })
                ]


                def failures = []
                metrics.each {
                    def limit = limits[it.key]
                    if (it.value < limit) {
                        failures.add("- ${it.key} coverage rate is: ${it.value}%, minimum is ${limit}%")
                    }
                }

                if (failures) {
                    logger.quiet("------------------ Code Coverage Failed -----------------------")
                    failures.each {
                        logger.quiet(it)
                    }
                    logger.quiet("---------------------------------------------------------------")
                    throw new GradleException("Code coverage failed")
                } else{
                    logger.quiet("Passed Code Coverage Checks")
                }
            }
        }
    }

    junitPlatformTest {
        environment("APPINSIGHTS_INSTRUMENTATIONKEY", "some-key")
    }

    test {
        environment("APPINSIGHTS_INSTRUMENTATIONKEY", "some-key")
        reports.junitXml.setDestination((File)rootProject.testResultsDir)
    }

    check.dependsOn jacocoTestReport

    checkstyle {
        maxWarnings = 999  // In the Ideal world this should be 0
        toolVersion = '8.8'
        configDir = new File(rootDir, 'config/checkstyle')
    }

    tasks.withType(com.github.spotbugs.SpotBugsTask) {
        reports {
            xml.enabled = false
            html.enabled = true
        }
    }

// Delete me once there is no more bug
    spotbugs {
        ignoreFailures = true
    }
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

// tag::wrapper[]
task wrapper(type: Wrapper) {
    gradleVersion = '4.6'
}
// end::wrapper[]

task projectVersion {
    description 'Prints the version of this project; used for publishing JAR file'
    doLast {
        print project.version
    }
}
sonarqube {
    properties {
        property "sonar.junit.reportPaths", 'build/test-results/junit-platform'
        property "sonar.jacoco.reportPaths", "${project.buildDir}/jacoco/junitPlatformTest.exec"
        property "sonar.exclusions", "**/entity/*.java,**/model/*.java,**/AbstractDefinitionRepositoryDecorator.java,**/data/*Data.java,**/ControllerExceptionHandler.java,**/GenericLayoutEntityValidatorImpl.java,**/JurisdictionServiceImpl.java"
        property "sonar.cpd.exclusions", "**/entity/*.java,**/model/*.java"
        property "sonar.jacoco.excludes", "**/entity/*.java,**/model/*.java,**/AbstractDefinitionRepositoryDecorator.java,**/data/*Data.java,**/*Controller.java,**/WorkBasketUserDefaultService.java,**/*Exception.java,**/ControllerExceptionHandler.java,**/GenericLayoutEntityValidatorImpl.java,**/JurisdictionServiceImpl.java"
        property "sonar.coverage.exclusions", "**/entity/*.java,**/model/*.java,**/AbstractDefinitionRepositoryDecorator.java,**/data/*Data.java,**/*Controller.java,**/WorkBasketUserDefaultService.java,**/*Exception.java,**/CaseTypeItem.java,**/ApplicationParams.java,**/CaseTypePresentationControllerService.java,**/DisplayService.java,**/DisplayItemAdapterService.java,**/DisplayApiPresentationControllerService.java,**/ControllerExceptionHandler.java,**/GenericLayoutEntityValidatorImpl.java,**/JurisdictionServiceImpl.java"
        property "sonar.projectName", "ccd-definition-store-api"
        property "sonar.projectKey", "ccd-definition-store-api"
    }
}

idea {
    project {
        ipr {
            withXml { provider ->
                // Get XML as groovy.util.Node to work with.
                def projectXml = provider.asNode()
                // Find compiler configuration component.
                def compilerConfiguration = projectXml.component.find { component ->
                    component.'@name' == 'CompilerConfiguration'
                }
                // Replace current annotationProcessing
                // that is part of the compiler configuration.
                def currentAnnotationProcessing = compilerConfiguration.annotationProcessing
                currentAnnotationProcessing.replaceNode {
                    annotationProcessing {
                        profile(name: 'Default', default: true, enabled: true) {
                            processorPath(useClasspath: true)
                        }
                    }
                }
            }
        }
    }
}

// this allows ./gradlew run
jar {
    manifest {
        attributes 'Implementation-Title': project.name,
                'Implementation-Version': project.version
    }
    configurations {
        jar.archiveName = 'case-definition-store-api.jar'
    }
}

// Although there are no sources to compile, Jenkins pipeline needs the jar file to be here
dependencies {
    compile "org.hibernate:hibernate-core:${hibernateVersion}"
    compile "org.hibernate:hibernate-entitymanager:${hibernateVersion}"
    compile project(':application')
}

task smoke(type: Test) {
    environment("APPINSIGHTS_INSTRUMENTATIONKEY", "some-key")
    logger.quiet("!!!! Smoke test stage to be configured !!!!")
}

task functional(type: Test, dependsOn: ":aat:functional")

task codeCoverageReport(type: JacocoReport, dependsOn: allprojects*.test) {

    // Gather execution data from all subprojects
    // (change this if you e.g. want to calculate unit test/integration test coverage separately)
    executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")

    // Add all relevant sourcesets from the subprojects
    allprojects.each {
        sourceSets it.sourceSets.main
    }

    reports {
        csv.enabled = false
        html.enabled = true
        html.destination = file("${buildDir}/reports/jacoco/html")
        xml.enabled = true
        xml.destination = file("${buildDir}/reports/jacoco/jacocoTestReport.xml")
    }
}

// for cnp pipeline
task dependencyCheck(dependsOn: dependencyCheckAnalyze)
